[
  {
    "id_questao": "2024_1_q2",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 2,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Análise de Complexidade",
        "subarea": "Notação Big O"
      },
      {
        "nome": "Algoritmos",
        "subarea": null
      }
    ],
    "enunciado": "Se um programador fez testes para avaliar o tempo de execução para entradas de tamanho 1000 em um programa $O(n^2)$ e obteve tempo de 1 minuto, quanto tempo demoraria para uma entrada de tamanho 2000? (considere que 1000 é suficientemente grande para desprezar fatores menores na função de custo e que o custo unitário por operação não variou com o tamanho do problema entre os dois experimentos)",
    "opcoes": [
      {
        "letra": "a",
        "texto": "2 minutos",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "3 minutos",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "4 minutos",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "9 minutos",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A complexidade de tempo do algoritmo é quadrática, ou seja, $T(n) \\approx c \\cdot n^2$. Se o tamanho da entrada `n` dobra (de 1000 para 2000, um fator de 2), o tempo de execução deve aumentar pelo quadrado desse fator, que é $2^2 = 4$.\n\n**Cálculo:**\n- Tempo inicial para n=1000: 1 minuto.\n- Fator de aumento do tempo: $ (2000/1000)^2 = 2^2 = 4 $.\n- Novo tempo para n=2000: 1 minuto * 4 = 4 minutos.\n\n- **(a) Incorreto:** Seria 2 minutos se a complexidade fosse linear, $O(n)$.\n- **(b, d) Incorreto:** São valores que não correspondem à proporção quadrática."
  },
  {
    "id_questao": "2024_1_q4",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 4,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Algoritmos",
        "subarea": "Busca"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "Arrays"
      }
    ],
    "enunciado": "Dado o vetor abaixo, o qual é apresentado em uma tabela onde a primeira linha indica a posição dos elementos e a segunda linha os valores armazenados.\n\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n|---|---|---|---|---|---|---|---|---|\n| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 |\n\nUma busca binária no mesmo compararia a chave 13 com os seguintes valores do vetor:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "2, 6, 10, 14 e 18",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "10, 14 e 18",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Nenhuma porque a chave não existe no vetor",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "10, 14 e 12",
        "correta": true
      }
    ],
    "explicacao_geral": "**Raciocínio:** A busca binária funciona dividindo repetidamente o intervalo de busca pela metade.\n- Vetor: `[2, 4, 6, 8, 10, 12, 14, 16, 18]` (índices 0 a 8). Chave = 13.\n\n**Passos:**\n1. **Intervalo [0, 8]:** `meio = (0+8)/2 = 4`. Compara com `vetor[4]` que é **10**. Como `13 > 10`, o novo intervalo de busca é à direita: [5, 8].\n2. **Intervalo [5, 8]:** `meio = (5+8)/2 = 6`. Compara com `vetor[6]` que é **14**. Como `13 < 14`, o novo intervalo de busca é à esquerda: [5, 5].\n3. **Intervalo [5, 5]:** `meio = (5+5)/2 = 5`. Compara com `vetor[5]` que é **12**. Como `13 > 12`, o novo intervalo seria [6, 5].\n4. O laço termina, pois `inicio > fim`. A chave 13 não é encontrada.\n\nAs comparações foram feitas com os valores **10, 14 e 12**, nesta ordem."
  },
  {
    "id_questao": "2024_1_q6",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 6,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Análise de Complexidade",
        "subarea": null
      }
    ],
    "enunciado": "Sobre árvores vermelho e preto contento pelo menos 128 elementos, sabe-se que:\nI) Uma árvore vermelho e preto tem altura máxima inferior a $3 \\cdot log_2(n)$, onde n é o número de chaves, pois ela é balanceada\nII) No pior caso, uma árvore vermelho e preto tem altura pior do que o pior caso de uma árvore binária de pesquisa\nIII) O balanceamento na árvore falha apenas para os casos de inserção em ordem crescente, situação em que a altura esperada da árvore pode chegar a passar da raiz quadrada do número de elementos quando o número de elementos for muito grande.",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Apenas I é verdadeira",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "Apenas II é verdadeira",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Apenas III é verdadeira",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Apenas I e II são verdadeiras",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:**\n- **I (Verdadeira):** Uma propriedade fundamental das árvores rubro-negras é que sua altura `h` é, no máximo, $2 \\cdot log_2(n+1)$. Para $n \\ge 128$, $2 \\cdot log_2(n+1)$ é definitivamente menor que $3 \\cdot log_2(n)$. Isso ocorre porque ela é uma árvore auto-balanceada.\n- **II (Falsa):** O pior caso de altura para uma árvore rubro-negra é $O(log n)$, enquanto o pior caso para uma árvore binária de pesquisa (não balanceada) é $O(n)$. Portanto, a altura da árvore rubro-negra é significativamente melhor (menor), não pior.\n- **III (Falsa):** Árvores rubro-negras são projetadas para se auto-balancear em *todas* as operações de inserção e remoção, incluindo inserções em ordem. O mecanismo de rotações e recolorações garante que a propriedade de balanceamento nunca falhe.\n\nConclusão: Apenas a afirmativa I está correta."
  },
  {
    "id_questao": "2024_1_q8",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 8,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "Dentro das árvores AVL, considera-se uma árvore balanceada somente quando:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "A diferença de altura da subárvore esquerda para a subárvore direita não exceda de 1, e as subárvores esquerda e direita também são balanceadas.",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "Todos os nós da árvore têm 0 ou 2 subárvores, e a altura mínima da raiz é 2.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Não existe diferença entre as alturas das subárvores dos nós.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Todos os nós com chaves de busca menores que a chave da raiz encontram-se na subárvore esquerda.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A definição de uma árvore AVL é recursiva.\n- **(a) Correto:** Esta é a definição precisa. Para qualquer nó da árvore, a diferença de altura entre suas subárvores esquerda e direita (conhecida como fator de balanceamento) deve ser -1, 0 ou 1. Além disso, ambas as subárvores devem ser, elas mesmas, árvores AVL.\n- **(b) Incorreto:** Descreve uma árvore binária cheia, uma condição mais restritiva e diferente da de uma AVL.\n- **(c) Incorreto:** Descreve uma árvore binária perfeita, que é uma condição ainda mais restrita.\n- **(d) Incorreto:** Esta é a propriedade de qualquer Árvore Binária de Busca (BST), não a condição específica de balanceamento da AVL."
  },
  {
    "id_questao": "2024_1_q9",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 9,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Listas Encadeadas"
      }
    ],
    "enunciado": "Considere uma lista ligada na qual cada nó contém um campo info (um valor inteiro) e um campo prox (um ponteiro para o próximo nó). O início da lista é indicado simplesmente por um ponteiro para o primeiro elemento. A declaração a seguir especifica o tipo da lista e declara uma lista inicialmente vazia.\n\ntypedef struct lista Lista;\nstruct lista {\n  int info;\n  Lista *prox;\n} *uma_lista = NULL;\n\nQual das alternativas a seguir contém um código que insere corretamente um novo nó no início da lista?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "void insere (Lista *lista, int info) { ... }",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "void insere (Lista *lista, int info) { ... }",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "void insere (Lista **lista, int info) {\n  Lista *novo = malloc(sizeof (Lista));\n  novo->info = info;\n  novo->prox = *lista;\n  *lista = novo;\n}",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "void insere (Lista **lista, int info) { ... }",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Para modificar o ponteiro que marca o início da lista (o `head`), a função precisa receber o endereço desse ponteiro. Em C, isso é feito usando um ponteiro para ponteiro (`**`).\n\n- **(a, b) Incorreto:** Recebem `Lista *lista`, que é uma cópia do ponteiro. Qualquer alteração em `lista` dentro da função será local e não afetará o ponteiro original `uma_lista` fora da função.\n- **(c) Correto:** A função recebe `Lista **lista`. `*lista` refere-se ao ponteiro original. A lógica está correta: 1) aloca um novo nó; 2) faz o `prox` do novo nó apontar para o antigo início da lista (`*lista`); 3) atualiza o ponteiro de início da lista para que ele aponte para o novo nó (`*lista = novo`).\n- **(d) Incorreto:** Apesar da assinatura correta, a lógica implementa uma inserção no final da lista, não no início, e de forma incorreta (`*lista->prox` tem precedência errada e não percorre a lista)."
  },
  {
    "id_questao": "2024_1_q10",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 10,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Algoritmos de Ordenação",
        "subarea": "QuickSort"
      },
      {
        "nome": "Algoritmos de Ordenação",
        "subarea": "Insertion Sort"
      },
      {
        "nome": "Algoritmos de Ordenação",
        "subarea": "MergeSort"
      }
    ],
    "enunciado": "Considere as seguintes afirmações sobre algoritmos de ordenação.\nI) O método da inserção (insertion sort) pode ser mais eficiente do que o quick sort se o vetor for pequeno e tiver poucos elementos fora de ordem.\nII) O quick sort é o melhor algoritmo de ordenação em situações típicas e, para vetores muito grandes, ele é sempre aconselhável em detrimento de outros algoritmos de ordenação.\nIII) O método da intercalação (merge sort) é eficiente, mas normalmente requer memória adicional para realizar a intercalação. É possível intercalar os elementos no próprio vetor, mas isso exige passos adicionais.",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Todas as afirmações são verdadeiras",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Apenas I e II são verdadeiras",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Apenas I e III são verdadeiras",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "Apenas II e III são verdadeiras",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:**\n- **I (Verdadeira):** O Insertion Sort tem baixa sobrecarga de constantes e é adaptativo. Para vetores pequenos ou quase ordenados, seu desempenho ($O(n)$ no melhor caso) pode superar o Quicksort, que tem uma sobrecarga maior devido à recursão e particionamento.\n- **II (Falsa):** A palavra \"sempre\" torna a afirmação falsa. O pior caso do Quicksort é $O(n^2)$, que pode ser um problema para certas entradas. Algoritmos como Mergesort e Heapsort garantem $O(n \\cdot log n)$ no pior caso, sendo mais seguros para vetores muito grandes onde o pior caso não pode ser arriscado.\n- **III (Verdadeira):** A implementação padrão do Mergesort usa um vetor auxiliar de tamanho `n`, resultando em $O(n)$ de espaço extra. Embora existam versões \"in-place\" (no próprio vetor), elas são mais complexas e geralmente menos eficientes em tempo.\n\nConclusão: As afirmativas I e III estão corretas."
  },
  {
    "id_questao": "2024_1_q11",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 11,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Recursão",
        "subarea": null
      },
      {
        "nome": "Análise de Complexidade",
        "subarea": null
      }
    ],
    "enunciado": "Considere a função em Python a seguir.\n\ndef chamada (n):\n  print(\"PPGI\")\n  if n <= 1:\n    return n\n  else:\n    return (chamada (n-1) + chamada (n-2))\n\nQuantas vezes a palavra PPGI é impressa na tela ao executar chamada (4)?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "3",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "5",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "9",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "15",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A função `chamada(n)` imprime \"PPGI\" uma vez e depois chama a si mesma para `n-1` e `n-2`. Vamos contar o número de chamadas (e, portanto, de impressões).\n\n**Árvore de Recursão:**\n- `chamada(4)` -> imprime 1 vez + chamadas para `chamada(3)` e `chamada(2)`.\n- `chamada(3)` -> imprime 1 vez + chamadas para `chamada(2)` e `chamada(1)`.\n- `chamada(2)` -> imprime 1 vez + chamadas para `chamada(1)` e `chamada(0)`.\n- `chamada(1)` -> imprime 1 vez.\n- `chamada(0)` -> imprime 1 vez.\n\n**Contagem:**\n- C(4) = 1 + C(3) + C(2)\n- C(3) = 1 + C(2) + C(1)\n- C(2) = 1 + C(1) + C(0)\n- C(1) = 1\n- C(0) = 1\n\n- C(2) = 1 + 1 + 1 = 3\n- C(3) = 1 + 3 + 1 = 5\n- C(4) = 1 + 5 + 3 = 9\n\nTotal de impressões: **9**."
  },
  {
    "id_questao": "2024_1_q12",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 12,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Recursão",
        "subarea": null
      }
    ],
    "enunciado": "Considere a função em Python a seguir.\n\ndef chamada (n):\n  print(\"PPGI\")\n  if n <= 1:\n    return n\n  else:\n    return (chamada (n-1) + chamada (n-2))\n\nQual o retorno da execução chamada(4)?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "3",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "5",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "8",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "13",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A função calcula um valor semelhante à sequência de Fibonacci, mas com casos base específicos. O valor de retorno é o que importa aqui, não a impressão.\n\n**Cálculo do Retorno:**\n- `chamada(0)` retorna 0.\n- `chamada(1)` retorna 1.\n- `chamada(2)` retorna `chamada(1) + chamada(0)` = 1 + 0 = 1.\n- `chamada(3)` retorna `chamada(2) + chamada(1)` = 1 + 1 = 2.\n- `chamada(4)` retorna `chamada(3) + chamada(2)` = 2 + 1 = 3.\n\nO valor final retornado pela execução `chamada(4)` é **3**."
  },
  {
    "id_questao": "2024_1_q13",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 13,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "Sobre árvores vermelho-preto, considere as afirmações:\nI) A raiz é preta\nII) Toda subárvore nula é preta\nIII) Se um nó é preto, então os filhos são vermelhos\n\nSão verdadeiras:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Apenas a afirmação I",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Apenas as afirmações I e II",
        "correta": true
      },
      {
        "letra": "c",
        "texto": "Apenas as afirmações II e III",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Todas as afirmações",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio - Propriedades da Árvore Rubro-Negra:**\n- **I (Verdadeira):** A propriedade 2 de uma árvore rubro-negra afirma que o nó raiz é sempre preto.\n- **II (Verdadeira):** A propriedade 3 afirma que toda folha (nó NIL ou nulo) é preta. Isso simplifica a manutenção das outras propriedades.\n- **III (Falsa):** Esta é a inversão de uma propriedade real. A regra correta (propriedade 4) é que *se um nó é vermelho, então ambos os seus filhos devem ser pretos*. Não há restrição sobre os filhos de um nó preto, eles podem ser vermelhos ou pretos.\n\nConclusão: Apenas as afirmativas I e II estão corretas."
  },
  {
    "id_questao": "2024_1_q14",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 14,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "As árvores rubro-negras têm como uma de suas características",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Todo nó vermelho (rubro) tem dois filhos pretos",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "A diferença de altura da subárvore esquerda para a subárvore direita não exceda de 1, e as subárvores esquerda e direita também são balanceadas",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Todo nó preto (negro) tem, pelo menos, uma subárvore cuja raiz é vermelha (rubra)",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "A altura das subárvores é o fator usado para determinar o balanceamento, e pode exceder em 50% a diferença entre elas.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:**\n- **(a) Correto:** Esta é a chamada \"propriedade vermelha\" (ou propriedade 4) das árvores rubro-negras. Ela impede que existam dois nós vermelhos em sequência em qualquer caminho da raiz a uma folha, o que é crucial para garantir o balanceamento.\n- **(b) Incorreto:** Esta é a definição da condição de balanceamento de uma árvore AVL, que se baseia diretamente na diferença de altura.\n- **(c) Incorreto:** Um nó preto pode ter filhos pretos. Não há tal exigência.\n- **(d) Incorreto:** O balanceamento em árvores rubro-negras não é determinado diretamente pela diferença de altura, mas sim pelas propriedades de cor e pela \"altura negra\" (número de nós pretos em um caminho)."
  },
  {
    "id_questao": "2024_1_q15",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 15,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Análise de Complexidade",
        "subarea": "Notação Big O"
      }
    ],
    "enunciado": "A altura de uma árvore rubro negra com n nós é:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "de, no máximo, n*log(n)",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "de, no máximo, 2*log(n+1)",
        "correta": true
      },
      {
        "letra": "c",
        "texto": "no pior caso, n*n",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "de, no máximo, log(n-1)",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Uma das garantias mais importantes de uma árvore rubro-negra é que ela permanece 'razoavelmente' balanceada. Um teorema fundamental prova que a altura `h` de uma árvore rubro-negra com `n` nós internos é limitada superiormente.\n\n- **(b) Correto:** A altura máxima de uma árvore rubro-negra é $h \\le 2 \\cdot log_2(n+1)$. Isso garante uma complexidade de busca, inserção e remoção no pior caso de $O(log n)$.\n- **(a, c) Incorreto:** São limites superiores muito pessimistas e incorretos. $O(n \\cdot log n)$ e $O(n^2)$ são complexidades associadas a algoritmos, não à altura de uma árvore balanceada.\n- **(d) Incorreto:** $O(log n)$ é a classe de complexidade correta, mas a fórmula $2 \\cdot log_2(n+1)$ é o limite superior mais preciso e formalmente demonstrado."
  },
  {
    "id_questao": "2024_1_q17",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 17,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Pilhas"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "Filas"
      }
    ],
    "enunciado": "Qual é a principal diferença entre uma pilha e uma fila?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Uma pilha segue o princípio FIFO (First In, First Out), enquanto uma fila segue o princípio LIFO (Last In, First Out).",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Uma pilha segue o princípio LIFO (Last In, First Out), enquanto uma fila segue o princípio FIFO (First In, First Out).",
        "correta": true
      },
      {
        "letra": "c",
        "texto": "Pilhas e filas funcionam da mesma forma, não há diferença entre elas.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Pilhas e filas não são estruturas de dados comuns na programação.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A diferença fundamental entre pilhas e filas está na ordem de acesso e remoção dos elementos.\n- **Pilha (Stack):** Opera sob o princípio **LIFO (Last-In, First-Out)**. O último elemento a ser inserido é o primeiro a ser removido. A analogia é uma pilha de pratos.\n- **Fila (Queue):** Opera sob o princípio **FIFO (First-In, First-Out)**. O primeiro elemento a ser inserido é o primeiro a ser removido. A analogia é uma fila de pessoas em um caixa.\n\n- **(b) Correto:** Descreve corretamente os princípios de cada estrutura.\n- **(a) Incorreto:** Inverte os princípios.\n- **(c, d) Incorreto:** São afirmações factualmente erradas; são estruturas distintas e extremamente comuns."
  },
  {
    "id_questao": "2024_1_q18",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 18,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Arrays"
      }
    ],
    "enunciado": "Na linguagem de programação C, quando um vetor é passado para uma sub-rotina/função como argumento, o que realmente é passado:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "O endereço de memória do primeiro elemento do vetor",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "O endereço de memória do primeiro e do último elemento do vetor",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Os valores dos elementos do vetor",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "O número de elementos na memória do vetor",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A linguagem C trata a passagem de vetores para funções de uma maneira específica para eficiência.\n- **(a) Correto:** Quando um vetor é passado como argumento para uma função, ele \"decai\" para um ponteiro para seu primeiro elemento. A função recebe o endereço de memória onde o vetor começa. É por isso que modificações no vetor dentro da função afetam o vetor original na função chamadora (não é uma cópia dos valores).\n- **(b) Incorreto:** Apenas o endereço inicial é passado. O final do vetor ou seu tamanho devem ser passados como um argumento separado.\n- **(c) Incorreto:** Passar todos os valores por cópia (passagem por valor) seria ineficiente para vetores grandes. Isso não é o que C faz.\n- **(d) Incorreto:** O tamanho do vetor não é passado implicitamente; deve ser fornecido como outro parâmetro."
  },
  {
    "id_questao": "2024_1_q19",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 19,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Algoritmos",
        "subarea": null
      }
    ],
    "enunciado": "Analise o código a seguir:\n\nint subrotina (int x) {\n  int i, z=0;\n  for (i=1; i<x; i++)\n    z += i;\n  return z;\n}\n\nint main() {\n  int z, i, x;\n  for(i=1; i<5; i++){\n    printf(\"Informe um numero: \");\n    scanf(\"%d\",&z);\n    x=subrotina(z);\n    printf(\"%d\\n\",x);\n  }\n  return 0;\n}\n\nQual o resultado impresso na tela, considerando que o usuário informou os respectivos valores de entrada (9, 7, 6, 10)?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "15, 105, 28, 3",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "28, 45, 91, 21",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "36, 21, 15, 45",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "36, 55, 78, 45",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A função `subrotina(x)` calcula a soma de todos os inteiros de 1 até `x-1`. O programa principal chama essa função quatro vezes com as entradas fornecidas.\n\n**Cálculos:**\n- **Entrada 9:** `subrotina(9)` soma 1+2+3+4+5+6+7+8 = **36**.\n- **Entrada 7:** `subrotina(7)` soma 1+2+3+4+5+6 = **21**.\n- **Entrada 6:** `subrotina(6)` soma 1+2+3+4+5 = **15**.\n- **Entrada 10:** `subrotina(10)` soma 1+2+3+4+5+6+7+8+9 = **45**.\n\nA sequência de saída será `36`, `21`, `15`, `45`."
  },
  {
    "id_questao": "2024_1_q20",
    "prova_referencia": "2024-1.pdf",
    "numero_questao": 20,
    "ano_prova": 2024,
    "area": [
      {
        "nome": "Algoritmos",
        "subarea": null
      }
    ],
    "enunciado": "Marque a alternativa CORRETA do programa em C que atende o seguinte enunciado: \"Alguns restaurantes nos EUA cobram gorjeta de 18% para o garçom. Faça um programa em C que leia o valor gasto com as despesas realizadas em um restaurante e imprima o valor total com a gorjeta\":",
    "opcoes": [
      {
        "letra": "a",
        "texto": "#include<stdio.h>\nint main(void) {\n  float PT, E;\n  printf(\"Informe o valor\");\n  scanf(\"%f\",&E);\n  PT=E+E*1.18;\n  printf(\"Valor Total: %.2f\", PT);\n  return 0;\n}",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "#include<stdio.h>\nint main(void) {\n  float X, TG;\n  printf(\"Informe o valor\");\n  scanf(\"%f\",&X);\n  TG=X*0.18;\n  printf(\"Valor Total: %.2f\", TG);\n  return 0;\n}",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "#include<stdio.h>\nint main(void) {\n  float K, W;\n  printf(\"Informe o valor\");\n  scanf(\"%f\",&K);\n  W=K+K*0.18;\n  printf(\"Valor Total: %.2f\", W);\n  return 0;\n}",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "#include<stdio.h>\nint main(void) {\n  float PT, E;\n  printf(\"Informe o valor\");\n  scanf(\"%f\",&E);\n  PT=E*E*18/100;\n  printf (\"Valor Total: %.2f\", PT);\n  return 0;\n}",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** O valor total é o valor original (`Custo`) mais a gorjeta. A gorjeta é 18% do custo, ou seja, `Custo * 0.18`.\nFórmula: `Total = Custo + (Custo * 0.18)`\n\n- **(a) Incorreto:** Calcula `E + E*1.18`, que é `Custo + 118% de Custo`, resultando em 218% do Custo total. A gorjeta seria de 118%.\n- **(b) Incorreto:** Calcula `X * 0.18`, que é apenas o valor da gorjeta, não o valor total (custo + gorjeta).\n- **(c) Correto:** Calcula `K + K*0.18`. `K` é o custo original, e `K*0.18` é a gorjeta de 18%. A soma resulta no valor total correto.\n- **(d) Incorreto:** Calcula `E*E*18/100`, ou seja, `Custo² * 0.18`. A fórmula está matematicamente incorreta."
  }
]