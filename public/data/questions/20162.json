[
  {
    "id_questao": "2016_2_q1",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 1,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Análise de Complexidade",
        "subarea": "Notação Big O"
      },
      {
        "nome": "Algoritmos",
        "subarea": "Busca"
      }
    ],
    "enunciado": "Seja um vetor de inteiros com 400 elementos distintos ordenados em ordem crescente. Qual é o número máximo de iterações necessárias para encontrar um elemento qualquer desse vetor, caso seja utilizado o algoritmo de busca binária?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "9",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "8",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "7",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "200",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "400",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** O número máximo de comparações (iterações) em uma busca binária é dado pela complexidade de pior caso do algoritmo, que é $O(\\log_2 N)$, onde N é o número de elementos no vetor. O cálculo exato para o número máximo de iterações é $\\lceil \\log_2 N \\rceil$.\n\n**Cálculo:** Para N = 400, precisamos calcular $\\log_2(400)$.\n- Sabemos que $2^8 = 256$ e $2^9 = 512$.\n- Como $256 < 400 < 512$, o logaritmo de 400 na base 2 está entre 8 e 9.\n- No pior caso, o algoritmo pode precisar de até 9 comparações para encontrar o elemento ou determinar que ele não existe.\n\n- **(a) Correto:** O valor é 9.\n- **(b, c) Incorreto:** 8 ou 7 comparações não são suficientes para garantir a busca em um universo de 400 elementos.\n- **(d, e) Incorreto:** 200 ou 400 seriam valores relacionados a uma busca linear, não binária."
  },
  {
    "id_questao": "2016_2_q2",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 2,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Recursão",
        "subarea": "Técnicas recursivas e análise"
      }
    ],
    "enunciado": "Sobre as funções abaixo,\n\n| Função I | Função II |\n| :--- | :--- |\n| `int fatorial(int i) {` | `void fatorial() {` |\n| `if (i<=1) {` | `int fat[0]=1;` |\n| `return 1;` | `for (int j=1; j++;) {` |\n| `} else {` | `fat[j]=j*fat[j-1];` |\n| `fatorial(i-1);` | `}` |\n| `}` | `}` |\n| `}` | |\n\nAssinale a alternativa CORRETA:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Somente a função I é recursiva.",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "Ambas as funções são recursivas.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Somente a função II é recursiva.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "A função I não é recursivo e a função II é orientada a objeto.",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Ambas as funções não são recursivas.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Uma função é dita recursiva se ela chama a si mesma em sua definição.\n\n- **Função I:** A função `fatorial(int i)` contém uma chamada a `fatorial(i-1)` dentro de seu bloco `else`. Portanto, ela é recursiva. (Nota: há um erro no código, pois o resultado da chamada recursiva não é retornado, o que levaria a um comportamento indefinido, mas a característica de ser recursiva permanece).\n- **Função II:** A função `fatorial()` utiliza um laço `for` para calcular o fatorial de forma iterativa, armazenando os resultados em um vetor. Ela não chama a si mesma.\n\n- **(a) Correto:** Apenas a Função I satisfaz a definição de recursividade.\n- **(b, c, e) Incorreto:** A análise mostra que apenas a I é recursiva.\n- **(d) Incorreto:** A função I é recursiva e a função II não tem características de orientação a objetos."
  },
  {
    "id_questao": "2016_2_q3",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 3,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Grafos"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "As seguintes afirmações sobre árvores estão corretas, com EXCEÇÃO de:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "É um grafo conexo que admite ciclos.",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "É um grafo conexo e há exatamente um caminho entre dois vértices quaisquer.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Uma árvore com n vértices possui n-1 arestas.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Toda árvore é um grafo, mas nem todo grafo é uma árvore.",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Uma união disjunta de árvores forma uma floresta",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A questão pede a afirmação INCORRETA sobre árvores.\n\n- **(a) Incorreto (e portanto a resposta certa):** A definição fundamental de uma árvore é ser um **grafo acíclico** (não admite ciclos) e conexo. A afirmação de que admite ciclos está errada.\n- **(b) Correto:** Esta é uma propriedade fundamental das árvores. A existência de um caminho único entre quaisquer dois vértices é equivalente à definição de ser conexa e acíclica.\n- **(c) Correto:** Esta é uma propriedade fundamental de qualquer árvore com `n` vértices.\n- **(d) Correto:** Árvores são um tipo específico de grafo, então toda árvore é um grafo. No entanto, um grafo pode ter ciclos ou ser desconexo, então nem todo grafo é uma árvore.\n- **(e) Correto:** Esta é a definição de uma floresta em teoria dos grafos."
  },
  {
    "id_questao": "2016_2_q4",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 4,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Algoritmos de Ordenação",
        "subarea": "Selection Sort"
      }
    ],
    "enunciado": "Considere que o vetor abaixo será ordenado com o algoritmo de ordenação por seleção.\n`[4, 5, 3, 17, 2, 1, 22]`\nConsiderando-se que o vetor tem sua primeira posição contada como 0 (zero), a segunda troca de valores entre posições do vetor ocorrerá entre:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Posição 0 e posição 2",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Posição 0 e posição 7",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Posição 1 e posição 5",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "Posição 1 e posição 6",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Posição 3 e posição 5",
        "correta": false
      }
    ],
    "explicacao_geral": "**Alerta:** Existe uma aparente inconsistência no enunciado da prova. A ordenação por seleção do vetor fornecido (`[4, 5, 3, 17, 2, 1, 22]`) não resulta em uma segunda troca entre as posições 1 e 5. A explicação abaixo demonstra o raciocínio que levaria à resposta do gabarito, assumindo um provável erro de digitação no vetor da prova (por exemplo, se o vetor fosse `[4, 5, 3, 1, 17, 2, 22]`).\n\n**Raciocínio (com vetor corrigido para `[4, 5, 3, 1, 17, 2, 22]`):**\nO algoritmo de Ordenação por Seleção (Selection Sort) funciona da seguinte forma: para cada posição `i`, encontra o menor elemento no subvetor `vetor[i...fim]` e o troca com o elemento da posição `i`.\n\n- **Vetor inicial (hipotético):** `[4, 5, 3, 1, 17, 2, 22]`\n\n- **1ª Iteração (i=0):**\n  - Subvetor a ser analisado: `[4, 5, 3, 1, 17, 2, 22]`.\n  - O menor elemento é `1`, na posição `3`.\n  - **1ª Troca:** Troca `vetor[0]` (4) com `vetor[3]` (1).\n  - Vetor após a 1ª troca: `[1, 5, 3, 4, 17, 2, 22]`.\n\n- **2ª Iteração (i=1):**\n  - Subvetor a ser analisado: `[5, 3, 4, 17, 2, 22]` (elementos a partir da posição 1).\n  - O menor elemento é `2`, na posição `5` do vetor original.\n  - **2ª Troca:** Troca `vetor[1]` (5) com `vetor[5]` (2).\n  - Esta troca ocorre entre a **Posição 1 e a Posição 5**.\n\n**Análise do Vetor Original da Prova (`[4, 5, 3, 17, 2, 1, 22]`):**\n- **1ª Troca:** O menor elemento é `1` na posição `5`. Troca `vetor[0]` com `vetor[5]`. (Troca entre posições 0 e 5).\n- **2ª Troca:** O menor elemento no subvetor restante `[5, 3, 17, 2, 4, 22]` é `2`, na posição `4`. Troca `vetor[1]` com `vetor[4]`. (Troca entre posições 1 e 4). Este resultado não corresponde a nenhuma opção."
  },
  {
    "id_questao": "2016_2_q5",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 5,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Filas"
      }
    ],
    "enunciado": "Considere uma estrutura de fila (disciplina FIFO) de números inteiros com duas operações: INSERE(n) e RETIRA(). Considere, também, que a representação do estado da fila em um instante qualquer é realizada listando os elementos, de forma que o primeiro elemento, da esquerda para a direita, é o mais antigo presente na fila. Se a fila começa vazia, a sequência:\nINSERE(3) RETIRA() INSERE(2) INSERE(5) RETIRA() RETIRA() INSERE(1) RETIRA() INSERE(4)\nO estado final da fila será:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "12345",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "23145",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "314",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "45",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "5",
        "correta": false
      }
    ],
    "explicacao_geral": "**Alerta:** A execução da sequência de operações fornecida na questão resulta em um estado final `[4]`, que não corresponde a nenhuma das alternativas. A explicação abaixo detalha o traço que leva a este resultado. A resposta `(c) 314` marcada no gabarito oficial só seria alcançável com uma sequência de operações completamente diferente, indicando uma provável inconsistência na elaboração da questão ou do gabarito.\n\n**Raciocínio (Seguindo as regras da Fila - FIFO):**\nFIFO significa \"First-In, First-Out\". O primeiro elemento a entrar é o primeiro a sair.\n\n- **Estado Inicial:** `Fila = []`\n1.  `INSERE(3)` → `Fila = [3]`\n2.  `RETIRA()` → `Fila = []` (o 3 é removido)\n3.  `INSERE(2)` → `Fila = [2]`\n4.  `INSERE(5)` → `Fila = [2, 5]` (o 5 entra no final)\n5.  `RETIRA()` → `Fila = [5]` (o 2, mais antigo, é removido)\n6.  `RETIRA()` → `Fila = []` (o 5 é removido)\n7.  `INSERE(1)` → `Fila = [1]`\n8.  `RETIRA()` → `Fila = []` (o 1 é removido)\n9.  `INSERE(4)` → `Fila = [4]`\n\n- **Estado Final:** A fila contém apenas o elemento `[4]`. Nenhuma alternativa corresponde a este resultado."
  },
  {
    "id_questao": "2016_2_q6",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 6,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Listas Encadeadas"
      }
    ],
    "enunciado": "Marque a alternativa CORRETA. Uma lista duplamente encadeada tem como característica ser formada por elementos que:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "se concatenam de forma circular, de tal maneira que, ao chegar ao final da lista, o próximo elemento volta a ser o primeiro.",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "contêm, além de um ou mais campos chave, mais um campo de ponteiro: o próximo, que permite o acesso ao elemento que sucede o atual (o próximo) presente na mesma lista.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "contêm, além de um campo chave, mais um campo de ponteiro: o próximo, que permite o acesso ao elemento que sucede o atual (o próximo) presente na mesma lista, de tal forma que os campos chave estão ordenados, ou seja, a chave do próximo é sempre maior ou igual à chave do atual elemento.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "contêm, além de um ou mais campos chave, dois outros campos de ponteiros: próximo e anterior, que permitem o acesso aos elementos adjacentes (próximo e anterior) presentes na mesma lista.",
        "correta": true
      },
      {
        "letra": "e",
        "texto": "Estão em posições adjacentes da memória, permitindo o acesso sequencial ao próximo e ao anterior de cada elemento pelo simples uso de um índice.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A questão pede a definição correta de uma lista duplamente encadeada.\n\n- **(d) Correto:** Esta é a definição exata. Cada nó em uma lista duplamente encadeada armazena, além do dado, dois ponteiros: um para o elemento seguinte (`próximo`) e outro para o elemento anterior (`anterior`). Isso permite a travessia da lista em ambas as direções.\n- **(a) Incorreto:** Descreve uma lista circular.\n- **(b) Incorreto:** Descreve uma lista simplesmente encadeada.\n- **(c) Incorreto:** Descreve uma lista simplesmente encadeada e ordenada.\n- **(e) Incorreto:** Descreve a estrutura de um array (vetor), onde os elementos são armazenados em posições de memória contíguas."
  },
  {
    "id_questao": "2016_2_q7",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 7,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "Considere a estrutura de dados Árvore Binária de Busca (ABB). Se inserirmos numa ABB inicialmente vazia os nós: 60, 10, 20, 80, 15, 75, 12 e 77, nessa ordem. Dado que a raiz encontra-se no nível 1, a altura da árvore e o nível do nó 15, respectivamente, serão:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "5 e 4",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "5 e 5",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "6 e 5",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "6 e 4",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "7 e 3",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Primeiro, construímos a Árvore Binária de Busca (ABB) inserindo os elementos na ordem dada. Depois, determinamos a altura da árvore e o nível do nó 15.\n\n**Construção da Árvore:**\n- `ins(60)`: A árvore é `(60)` - Nível 1.\n- `ins(10)`: 10 < 60 → `(60 L:10)` - Nível 2.\n- `ins(20)`: 20 > 10 → `(10 R:20)` - Nível 3.\n- `ins(80)`: 80 > 60 → `(60 R:80)` - Nível 2.\n- `ins(15)`: 15 > 10 e 15 < 20 → `(20 L:15)` - Nível 4.\n- `ins(75)`: 75 < 80 → `(80 L:75)` - Nível 3.\n- `ins(12)`: 12 > 10, 12 < 20, 12 < 15 → `(15 L:12)` - Nível 5.\n- `ins(77)`: 77 > 75 → `(75 R:77)` - Nível 4.\n\n**Árvore Final:**\n```\n      60 (N1)\n     /   \\\n  10 (N2)  80 (N2)\n    \\      /\n    20(N3) 75(N3)\n   /        \\\n 15(N4)       77(N4)\n / \n12(N5)\n```\n\n**Análise:**\n- **Nível do nó 15:** O nó 15 está no 4º nível, contando a raiz como nível 1.\n- **Altura da Árvore:** A altura é o nível do nó mais profundo. O nó 12 está no nível 5, que é o caminho mais longo (60 → 10 → 20 → 15 → 12). Portanto, a altura da árvore é 5.\n\nO resultado é **altura 5** e **nível 4** para o nó 15."
  },
  {
    "id_questao": "2016_2_q8",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 8,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Pilhas"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "Filas"
      }
    ],
    "enunciado": "Sabendo que as seguintes operações foram realizadas:\n1. Dados foram inseridos numa PILHA na seguinte ordem: 11, 12, 23, 14, 25, 50, 8, 18, 29, 10.\n2. Repetiu-se 10 vezes o par de operações: retirada da PILHA; inserção na FILA.\n3. A FILA foi exibida (impressa).\n4. Repetiu-se 10 vezes o par de operações: retirada da FILA; inserção na PILHA.\n5. A PILHA foi exibida (impressa).\nAs possíveis estruturas exibidas nas operações 3 e 5 são:\nI) FILA (começo) 10-29-18-8-50-25-14-23-12-11 (fim)\nII) PILHA: (topo) 11-12-23-14-25-50-8-18-29-10\nIII) PILHA: (topo) 10-29-18-8-50-25-14-23-12-11\nIV) FILA: (começo) 11-12-23-14-25-50-8-18-29-10 (fim)\nV) A PILHA mostrada fica com os elementos em ordem invertida dos dados de entrada\nAs estruturas exibidas CORRETAMENTE nas operações 3 e 5 são:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "I e II",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "I e V",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "II e III",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "III e IV",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "III e IV",
        "correta": false
      }
    ],
    "explicacao_geral": "**Alerta:** O gabarito oficial indica a alternativa 'b' (I e V) como correta, no entanto, a afirmação V está logicamente incorreta com base na execução das operações. A análise abaixo demonstra que as afirmações I e II são as corretas, o que corresponde à alternativa 'a'.\n\n**Raciocínio (LIFO para Pilha, FIFO para Fila):**\n\n1.  **Inserção na Pilha:** Os dados `11, 12, ..., 10` são inseridos. O último a entrar, `10`, fica no topo.\n    - `Pilha (topo) = [10, 29, 18, 8, 50, 25, 14, 23, 12, 11]`\n\n2.  **Mover da Pilha para a Fila:** Retirar do topo da pilha e inserir no fim da fila.\n    - Sai da pilha: `10, 29, 18, ...`. Entra na fila na mesma ordem.\n    - `Fila (começo) = [10, 29, 18, 8, 50, 25, 14, 23, 12, 11] (fim)`\n\n3.  **Exibir Fila:** O resultado corresponde exatamente à **Afirmação I**. A afirmação IV está incorreta.\n\n4.  **Mover da Fila para a Pilha:** Retirar do começo da fila e inserir no topo da pilha.\n    - Sai da fila: `10, 29, 18, ...`. Entra na pilha.\n    - Após retirar `10` e inserir: `Pilha = [10]`\n    - Após retirar `29` e inserir: `Pilha = [29, 10]`\n    - ...\n    - `Pilha Final (topo) = [11, 12, 23, 14, 25, 50, 8, 18, 29, 10]`\n\n5.  **Exibir Pilha:** O resultado corresponde exatamente à **Afirmação II**. A afirmação III está incorreta.\n\n- **Análise da Afirmação V:** \"A PILHA mostrada fica com os elementos em ordem invertida dos dados de entrada\".\n  - Ordem de entrada: `11, 12, ..., 10`\n  - Pilha final: `11, 12, ..., 10` (lendo do topo para a base).\n  - A ordem é a **mesma**, não invertida. Portanto, a **Afirmação V é Falsa**.\n\n**Conclusão Lógica:** As afirmações corretas são a I e a II. A resposta deveria ser a alternativa (a)."
  },
  {
    "id_questao": "2016_2_q9",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 9,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Listas Encadeadas"
      }
    ],
    "enunciado": "Os registros em uma lista duplamente encadeada com 20 elementos possuem, cada um, três campos:\n1. próximo: um ponteiro para o próximo elemento da lista;\n2. valor: informação armazenada pelo elemento;\n3. anterior: um ponteiro para o elemento anterior da lista.\nSendo \"Z\" o décimo elemento desta lista e \"X\" e \"Y\" dois outros elementos que não pertencem à lista, sendo apontados, respectivamente, pelos seguintes ponteiros \"PZ\", \"PX\" e \"PY\", considere o trecho de código abaixo.\n`PY->próximo = PX;`\n`PX->anterior = PY;`\n`PX->próximo = PZ->próximo;`\n`PZ->próximo->anterior = PX;`\n`PZ->próximo = PY;`\n`PY->anterior = PZ;`\nEste trecho de código é usado para inserir na lista os elementos:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Y, logo após o Z, e X, logo após o Y.",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "Y, antes do Z, e X, logo após o Z",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Y, antes do Z, e X, antes do Y.",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "X, logo após o Z, e Y, logo após o X.",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "X, antes do Z, e Y, logo após o Z.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Vamos analisar o efeito de cada linha de código sobre os ponteiros dos nós Z, Y, X e o nó que originalmente sucede Z (vamos chamá-lo de Z_next).\n\n- **Estado Inicial:** `... <-> Z <-> Z_next <-> ...` e `Y`, `X` estão fora da lista.\n\n1.  `PY->próximo = PX;` e `PX->anterior = PY;`\n    - Estas duas linhas estabelecem uma ligação dupla entre Y e X. Agora temos a sublista `Y <-> X`.\n\n2.  `PX->próximo = PZ->próximo;`\n    - O ponteiro `próximo` de X agora aponta para o nó que Z apontava (Z_next). A lista agora se parece com: `Y <-> X -> Z_next`.\n\n3.  `PZ->próximo->anterior = PX;`\n    - O ponteiro `anterior` de Z_next (que era `PZ->próximo`) agora aponta para X. A ligação dupla entre X e Z_next está completa: `Y <-> X <-> Z_next`.\n\n4.  `PZ->próximo = PY;`\n    - O ponteiro `próximo` de Z agora aponta para Y. A ligação para frente está feita: `Z -> Y`.\n\n5.  `PY->anterior = PZ;`\n    - O ponteiro `anterior` de Y agora aponta para Z. A ligação dupla entre Z e Y está completa: `Z <-> Y`.\n\n- **Estado Final:** Juntando tudo, a estrutura final é `... <-> Z <-> Y <-> X <-> Z_next <-> ...`. O código insere a sequência Y e X, nessa ordem, imediatamente após o nó Z."
  },
  {
    "id_questao": "2016_2_q10",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 10,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Hashing"
      }
    ],
    "enunciado": "Considere as afirmações sobre um hash linear (sem encadeamento):\nI) É obrigatório o uso de várias funções de hash\nII) Não funciona com número de chaves maior que o tamanho da tabela hash\nIII) Quando acontece uma colisão, o valor a ser inserido é colocado no local no lugar do já existente.\nSobre as afirmações, sabe-se que:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Todas são verdadeiras",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Todas são falsas",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Apenas I e III são verdadeiras",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Apenas II é verdadeira",
        "correta": true
      },
      {
        "letra": "e",
        "texto": "Apenas I e II são verdadeiras",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** \"Hash linear\" refere-se a uma tabela hash com endereçamento aberto e sondagem linear para resolução de colisões.\n\n- **I) Falsa.** A sondagem linear usa apenas uma função hash, `h(k)`. Em caso de colisão, ela tenta as posições `(h(k) + i) % M` sequencialmente (para i=1, 2, 3...). O uso de múltiplas funções hash é característico de outras técnicas, como o hash duplo.\n- **II) Verdadeira.** No endereçamento aberto, cada posição (slot) da tabela pode armazenar apenas um elemento. Portanto, o número de chaves a serem inseridas não pode exceder o número de posições na tabela. O fator de carga (chaves/posições) deve ser no máximo 1.\n- **III) Falsa.** Quando ocorre uma colisão, o algoritmo não substitui o elemento existente. Ele procura a próxima posição livre de acordo com a estratégia de sondagem (no caso, a próxima posição sequencial) para inserir o novo elemento.\n\n**Conclusão:** Apenas a afirmação II está correta."
  },
  {
    "id_questao": "2016_2_q11",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 11,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Operações Fundamentais",
        "subarea": "Travessia"
      }
    ],
    "enunciado": "As sequências que representam os percursos da árvore da figura em pós-ordem e in-ordem são, respectivamente:\n\n```mermaid\ngraph TD\n    P --> Q\n    P --> R\n    Q --> S\n    Q --> T\n```",
    "opcoes": [
      {
        "letra": "a",
        "texto": "PQSTR e PQSTR",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "STQPR e STQRP",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "STQRP e SQTPR",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "RPQTS e STQRP",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "PTQRS e PQSTR",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:**\nA árvore representada é:\n- Raiz: P\n- Subárvore esquerda de P: raiz Q, com filhos S (esquerda) e T (direita).\n- Subárvore direita de P: folha R.\n\n**Percurso Pós-ordem (Pós-fixado):** A ordem é Esquerda - Direita - Raiz.\n1.  Vai para a subárvore esquerda (Q). \n2.  Vai para a subárvore esquerda de Q (S). Visita S.\n3.  Vai para a subárvore direita de Q (T). Visita T.\n4.  Visita a raiz Q.\n5.  Vai para a subárvore direita de P (R). Visita R.\n6.  Visita a raiz P.\n    - **Resultado Pós-ordem: S T Q R P**\n\n**Percurso Em-ordem (In-fixado):** A ordem é Esquerda - Raiz - Direita.\n1.  Vai para a subárvore esquerda (Q).\n2.  Vai para a subárvore esquerda de Q (S). Visita S.\n3.  Visita a raiz Q.\n4.  Vai para a subárvore direita de Q (T). Visita T.\n5.  Visita a raiz P.\n6.  Vai para a subárvore direita de P (R). Visita R.\n    - **Resultado Em-ordem: S Q T P R**\n\n**Conclusão:** As sequências são `STQRP` e `SQTPR`. A alternativa (c) une as duas: `STQRPeSQTPR`."
  },
  {
    "id_questao": "2016_2_q12",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 12,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Hashing"
      }
    ],
    "enunciado": "Considere as afirmações sobre hash linear e hash encadeado\nI) Hash encadeado funciona melhor em disco, pois as chaves sempre ficam próximas uma das outras, facilitando a varredura.\nII) Para uma tabela hash de tamanho M, tanto o hash linear quanto o hash encadeado podem receber uma quantidade de chaves C, onde C > M.\nIII) Quanto acontece uma colisão no hash encadeado, a chave é inserida na posição livre mais próxima da chave original.\nSobre as afirmações, sabe-se que:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Todas são verdadeiras",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Todas são falsas",
        "correta": true
      },
      {
        "letra": "c",
        "texto": "Apenas I e III são verdadeiras",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Apenas II é verdadeira",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Apenas I e II são verdadeiras",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Análise de cada afirmação sobre as técnicas de hashing.\n\n- **I) Falsa.** O Hash Linear (endereçamento aberto com sondagem linear) geralmente funciona melhor em disco porque mantém os elementos em posições de memória contíguas, o que melhora a localidade de referência. No Hash Encadeado, os nós da lista ligada podem estar espalhados pela memória, resultando em mais buscas de disco (seek operations).\n\n- **II) Falsa.** A afirmação é que AMBOS podem ter mais chaves que o tamanho da tabela (fator de carga > 1). Isso é verdade para o hash encadeado (as listas podem crescer indefinidamente), mas é FALSO para o hash linear (endereçamento aberto), que não pode armazenar mais chaves do que o número de posições na tabela.\n\n- **III) Falsa.** A descrição \"inserida na posição livre mais próxima da chave original\" corresponde à técnica de sondagem linear (hash linear), não ao hash encadeado. No hash encadeado, quando ocorre uma colisão, a nova chave é inserida na lista ligada correspondente àquela posição da tabela.\n\n**Conclusão:** Todas as três afirmações são falsas."
  },
  {
    "id_questao": "2016_2_q13",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 13,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "AVL"
      }
    ],
    "enunciado": "Em uma árvore AVL, todos os nós têm grau",
    "opcoes": [
      {
        "letra": "a",
        "texto": "0, 1 ou 2.",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "divisível por 2.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "2",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "1 e 2",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "maior ou igual a 2.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A questão pergunta sobre o grau dos nós em uma árvore AVL. O **grau de um nó** é o número de filhos que ele possui.\n\nUma árvore AVL é, por definição, uma **árvore binária** de busca. Em qualquer árvore binária, um nó pode ter no máximo dois filhos.\n\nPortanto, os possíveis graus para qualquer nó são:\n- **Grau 0:** O nó não tem filhos (é uma folha).\n- **Grau 1:** O nó tem apenas um filho (esquerdo ou direito).\n- **Grau 2:** O nó tem dois filhos.\n\n- **(a) Correto:** Cobre todas as possibilidades para uma árvore binária.\n- **(b, c, d, e) Incorreto:** São restrições que não se aplicam a todas as árvores AVL. Por exemplo, folhas têm grau 0, o que contradiz todas as outras opções."
  },
  {
    "id_questao": "2016_2_q14",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 14,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "BST"
      }
    ],
    "enunciado": "A estrutura de dados conhecida como Árvore Binária de Busca (ABB) encontra diversas aplicações em soluções práticas. Sobre esta estrutura é CORRETO afirmar:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Uma ABB é um conjunto finito de nós que possui um nó especial, chamado raiz, do qual partem os nós de duas árvores binárias distintas: a da esquerda e a da direita.",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Quando os elementos a serem inseridos na ABB estão em ordem crescente, resulta em uma ABB com altura mínima.",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Para se utilizar uma ABB como método de ordenação, basta fazer o caminhamento ou percurso \"em-ordem\" e obter todos os elementos ordenados.",
        "correta": true
      },
      {
        "letra": "d",
        "texto": "Uma característica que confere à ABB grande agilidade na pesquisa e recuperação de elementos é que seus nós são sempre rearranjados de forma que a árvore resultante é sempre perfeitamente balanceada.",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "ABB são um caso especial de listas encadeadas em que nenhum nó aponta para mais de 2 sucessores.",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Análise das afirmações sobre Árvores Binárias de Busca (ABB).\n\n- **(a) Incorreto:** A formulação está imprecisa. A raiz não \"parte nós\", ela tem ponteiros para duas **subárvores**, que por sua vez são ABBs.\n- **(b) Incorreto:** Inserir elementos em ordem crescente (ou decrescente) em uma ABB resulta no pior caso: uma árvore degenerada, que se assemelha a uma lista encadeada e tem **altura máxima**, não mínima.\n- **(c) Correto:** Uma das propriedades mais importantes da ABB é que um percurso **em-ordem (in-order)** visita os nós em sequência crescente de suas chaves. Isso permite que a árvore seja usada para ordenação.\n- **(d) Incorreto:** A ABB padrão **não** se auto-balanceia. Esta é uma característica de árvores especializadas como AVL ou Rubro-Negra.\n- **(e) Incorreto:** Árvores e listas são estruturas de dados fundamentalmente diferentes. Uma árvore é uma estrutura não-linear, enquanto uma lista é linear."
  },
  {
    "id_questao": "2016_2_q15",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 15,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Algoritmos de Ordenação",
        "subarea": null
      },
      {
        "nome": "Análise de Complexidade",
        "subarea": null
      }
    ],
    "enunciado": "Considere as afirmações a seguir sobre os algoritmos de ordenação Quicksort, MergeSort, HeapSort e InsertionSort\nI) São algoritmos estáveis: Insertion Sort, QuickSort e MergeSorte\nII) Pior caso tem número de operações quadrático (proporcional a uma constante vezes n²): InsertionSort, QuickSort\nIII) Utiliza um espaço extra proporcional a n² (proporcional ao quadrado do número de elementos): HeapSort,\nIV) A ordem das entradas é incapaz de influenciar o desempenho do algoritmo: InsertionSort, MergeSort\nMarque a alternativa que indica TODAS as afirmações INCORRETAS feitas:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "I e IV",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "I, III e IV",
        "correta": true
      },
      {
        "letra": "c",
        "texto": "I, II e III",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "I, II, III e IV",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "II e IV",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Avaliar a veracidade de cada afirmação.\n\n- **I) INCORRETA:** Um algoritmo é estável se preserva a ordem relativa de elementos com chaves iguais. Insertion Sort e MergeSort são estáveis, mas o **Quicksort não é estável**.\n\n- **II) CORRETA:** O pior caso de complexidade de tempo para o InsertionSort é $O(n^2)$ (vetor em ordem inversa). O pior caso para o Quicksort (com má escolha de pivô, como em um vetor já ordenado) também é $O(n^2)$.\n\n- **III) INCORRETA:** O HeapSort é um algoritmo de ordenação in-place, o que significa que ele requer uma quantidade de espaço extra constante, $O(1)$. Ele não utiliza espaço proporcional a $n^2$.\n\n- **IV) INCORRETA:** O desempenho do **InsertionSort é altamente dependente** da ordem inicial da entrada (melhor caso $O(n)$, pior caso $O(n^2)$). Embora o MergeSort tenha um desempenho $O(n \\log n)$ independente da ordem, a inclusão do InsertionSort torna a afirmação falsa.\n\n**Conclusão:** As afirmações I, III e IV estão incorretas."
  },
  {
    "id_questao": "2016_2_q16",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 16,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "AVL"
      }
    ],
    "enunciado": "Uma árvore AVL é uma árvore binária de busca com balanceamento automático que respeita algumas propriedades fundamentais. Como todas as árvores, ela tem uma propriedade chamada altura. Sabendo que a altura de uma folha é igual a um e que a altura de um nó pai é igual ao máximo das alturas de seus filhos mais um, qual estrutura NÃO pode representar uma árvore AVL?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Uma árvore com três nós e altura igual a três",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "Uma árvore com seis nós e altura igual a três",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Uma árvore com três nós e altura igual a dois",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Uma árvore vazia",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Uma árvore com dois nós",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A propriedade fundamental da árvore AVL é que para qualquer nó, a diferença de altura entre suas subárvores esquerda и direita (o fator de balanceamento) não pode ser maior que 1 (em módulo). A altura é definida como: `h(folha) = 1`, `h(nó) = 1 + max(h(filho_esq), h(filho_dir))`, e `h(nó_nulo) = 0`.\n\n- **(a) Uma árvore com três nós e altura igual a três:** Para ter 3 nós e altura 3, a árvore precisa ser uma \"vara\" (lista encadeada), por exemplo, Nó A -> Nó B -> Nó C. \n  - C é folha, `h(C) = 1`.\n  - B tem C como filho, `h(B) = 1 + h(C) = 2`.\n  - A tem B como filho, `h(A) = 1 + h(B) = 3`. A altura da árvore é 3.\n  - Vamos checar o fator de balanceamento (FB) da raiz A: `FB(A) = |h(subárvore_esq) - h(subárvore_dir)|`. Supondo que B seja o filho esquerdo, o FB de A é `|h(B) - h(nulo)| = |2 - 0| = 2`. Como o fator de balanceamento é 2, ele viola a propriedade da AVL. Portanto, esta estrutura **não pode** ser uma AVL.\n\n- **(b, c, d, e) Possíveis estruturas AVL:** Todas as outras opções descrevem estruturas que podem ser árvores AVL. Uma árvore vazia, uma com dois nós, uma com três nós em V (altura 2) e uma com seis nós (altura 3) podem ser construídas respeitando a regra de balanceamento."
  },
  {
    "id_questao": "2016_2_q17",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 17,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Algoritmos",
        "subarea": "Busca"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "Listas Encadeadas"
      }
    ],
    "enunciado": "Considere os códigos de funções abaixo, assumindo que os mesmos são usados dentro de um programa e que os todos os cabeçalhos necessários são incluídos:\n\n| /*QUADRO I) função que retorna 1 se a chave de busca chave, passada como parâmetro, ocorre dentro de um vetor de inteiros ordenado e retorna 0 caso a chave não ocorra no vetor. O vetor tem tamanho determinado pelo parâmetro tm */ | /* QUADRO II) Conta ocorrências de uma chave na lista encadeada, retornando o total de ocorrências, zero caso a chave não ocorra */ |\n| :--- | :--- |\n| `int buscaChave(int v[], int chave, int tm) {` | `int ContaOcorrenciasChave(tipoNo *prim, int chave) {` |\n| `while( (tm>=0) && (v[tm]!= chave)) tm--;` | `tipoNo *aux = prim;` |\n| `if (tm>=0) return 0;` | `int cont = 0;` |\n| `return 1;` | `int x;` |\n| `}` | `for ( (x=0; aux[x] != NULL; x++){` |\n| | `if(aux[x].dado == chave) cont++;` |\n| | `}` |\n| | `return x;` |\n| | `}` |\n\nMarque a alternativa correta dentre as afirmações abaixo:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "Os dois códigos executam as tarefas propostas sem gerar qualquer tipo de erro de lógica ou de vazamento de memória",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "Apenas o código I executa sem erros a tarefa proposta",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "Apenas o código II executa sem erros a tarefa proposta",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "Os dois códigos geram erros de vazamento de memória ou de falha de segmentação",
        "correta": true
      },
      {
        "letra": "e",
        "texto": "Nenhuma das alternativas anteriores",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** Análise dos erros em cada trecho de código.\n\n- **Código I (buscaChave):**\n  - **Erro de Lógica:** A função pretende retornar 1 se a chave for encontrada e 0 caso contrário. No entanto, a lógica está invertida. Se o laço `while` para porque `v[tm] == chave`, a condição `tm>=0` será verdadeira e a função retornará `0`. Se a chave não for encontrada, o laço termina com `tm = -1`, a condição `if` é falsa e a função retorna `1`. Ela retorna o oposto do que foi proposto.\n  - **Erro de Eficiência:** O comentário diz que o vetor está ordenado, mas o algoritmo implementa uma busca linear, que é ineficiente para vetores ordenados (uma busca binária seria apropriada).\n\n- **Código II (ContaOcorrenciasChave):**\n  - **Erro de Sintaxe/Tipo (Causa da Falha de Segmentação):** A função recebe um ponteiro para um nó de lista encadeada (`tipoNo *prim`). A variável `aux` recebe esse ponteiro. No entanto, o laço `for` tenta acessar `aux` como se fosse um array (`aux[x]`). Isso é um erro de tipo que levará a uma falha de segmentação (segmentation fault) ao tentar acessar memória inválida.\n  - **Erro de Lógica:** A função retorna `x`, que é o contador do laço `for` (número total de nós), em vez de retornar `cont`, que é a variável destinada a contar as ocorrências da chave.\n\n**Conclusão:** Ambos os códigos possuem erros graves. O Código I tem um erro de lógica fundamental, e o Código II tem erros que causam falha de segmentação e erro de lógica no retorno. Portanto, a alternativa (d) está correta."
  },
  {
    "id_questao": "2016_2_q18",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 18,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "Considere as definições a seguir.\nI) O nível do nó raiz de uma árvore é 1.\nII) O nível de qualquer nó subsequente é igual ao nível do seu nó pai mais 1.\nIII) A profundidade de uma árvore é igual ao maior nível encontrado dentre todos os seus nós\nPartindo-se das premissas acima, a menor e a maior quantidade de nós, respectivamente, que poderiam existir em uma árvore binária de profundidade 4 são:",
    "opcoes": [
      {
        "letra": "a",
        "texto": "4 e 15",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "3 e 15",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "3 e 16",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "4 e 16",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "5 e 14",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** As definições estabelecem que a profundidade (ou altura) é o número de níveis, com a raiz no nível 1. Uma árvore de profundidade 4 tem nós até o nível 4.\n\n- **Menor quantidade de nós:** Para atingir a profundidade 4 com o mínimo de nós, a árvore deve ser o mais \"fina\" possível, como uma lista encadeada (árvore degenerada). Precisamos de um nó em cada nível para chegar ao quarto nível.\n  - Nível 1: 1 nó (raiz)\n  - Nível 2: 1 nó\n  - Nível 3: 1 nó\n  - Nível 4: 1 nó\n  - Total mínimo: **4 nós**.\n\n- **Maior quantidade de nós:** Para ter o máximo de nós em uma profundidade 4, a árvore deve ser \"cheia\" até essa profundidade. O número de nós em uma árvore binária cheia de profundidade `d` (com raiz no nível 1) é a soma dos nós em cada nível: $2^{1-1} + 2^{2-1} + ... + 2^{d-1} = 2^d - 1$.\n  - Para d=4, o número máximo de nós é $2^4 - 1 = 16 - 1 = **15 nós**$.\n\n**Conclusão:** A menor quantidade é 4 e a maior é 15."
  },
  {
    "id_questao": "2016_2_q19",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 19,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      }
    ],
    "enunciado": "Uma árvore binária completa tem no 5º nível uma quantidade de nós igual a",
    "opcoes": [
      {
        "letra": "a",
        "texto": "16",
        "correta": true
      },
      {
        "letra": "b",
        "texto": "15",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "31",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "64",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "32",
        "correta": false
      }
    ],
    "explicacao_geral": "**Raciocínio:** A questão pergunta o número de nós que existem especificamente **no nível 5** de uma árvore binária completa. Uma árvore binária é completa se todos os seus níveis, exceto possivelmente o último, estão completamente preenchidos, e o último nível é preenchido da esquerda para a direita.\n\nAssumindo que a raiz está no nível 1, o número de nós em qualquer nível `L` de uma árvore binária completa (ou cheia) é dado por $2^{L-1}$.\n\n**Cálculo:**\n- Para o nível `L = 5`:\n- Número de nós = $2^{5-1} = 2^4 = 16$.\n\n- **(a) Correto:** O 5º nível tem 16 nós.\n- **(b, c, e) Incorreto:** 15 e 31 são o número total de nós em árvores cheias de profundidade 4 e 5, respectivamente. 32 seria o número de nós no 6º nível.\n- **(d) Incorreto:** Valor não relacionado."
  },
  {
    "id_questao": "2016_2_q20",
    "prova_referencia": "2016-2.pdf",
    "numero_questao": 20,
    "ano_prova": 2016,
    "area": [
      {
        "nome": "Estruturas de Dados",
        "subarea": "Árvores"
      },
      {
        "nome": "Estruturas de Dados",
        "subarea": "BST"
      }
    ],
    "enunciado": "Considere uma árvore binária de busca cujos nós armazenam números inteiros variando de 1 a 100, na qual se quer buscar o número 54. Qual das seguintes sequências representa uma sequência de busca válida dentro desta árvore?",
    "opcoes": [
      {
        "letra": "a",
        "texto": "5, 18, 34, 60, 40, 52, 54",
        "correta": false
      },
      {
        "letra": "b",
        "texto": "25, 27, 28, 26, 60, 50, 58, 54",
        "correta": false
      },
      {
        "letra": "c",
        "texto": "37, 70, 32, <não encontrou>",
        "correta": false
      },
      {
        "letra": "d",
        "texto": "40, 70, 43, 44, 73, 57, 54",
        "correta": false
      },
      {
        "letra": "e",
        "texto": "Nenhuma das alternativas anteriores",
        "correta": true
      }
    ],
    "explicacao_geral": "**Alerta:** O gabarito oficial indica a alternativa 'e' como correta. No entanto, uma análise detalhada mostra que a alternativa 'a' e 'c' descrevem sequências de busca válidas em uma Árvore Binária de Busca (ABB), o que indica uma inconsistência na questão ou no gabarito. A explicação abaixo detalha a análise de cada opção.\n\n**Raciocínio:** Uma sequência de busca em uma ABB, para encontrar uma chave `K`, deve seguir a regra: a partir de um nó `N`, se `K < N.chave`, o próximo nó deve estar na subárvore esquerda de `N`; se `K > N.chave`, o próximo nó deve estar na subárvore direita de `N`.\n\n- **a) 5, 18, 34, 60, 40, 52, 54:** Buscando 54.\n  - `5<54` (dir) → `18<54` (dir) → `34<54` (dir) → `60>54` (esq) → `40<54` (dir) → `52<54` (dir) → `54`. **Esta sequência é VÁLIDA.**\n\n- **b) 25, 27, 28, 26, ...:** Buscando 54.\n  - `28<54`. O algoritmo de busca DEVE ir para a direita. A sequência mostra o próximo nó como `26`, que é menor que `28`, implicando ir para a esquerda. **Esta sequência é INVÁLIDA.**\n\n- **c) 37, 70, 32, <não encontrou>:** Buscando 54.\n  - `37<54` (dir) → `70>54` (esq) → `32<54` (dir) → ... e a busca termina. **Esta sequência é VÁLIDA** como uma busca sem sucesso.\n\n- **d) 40, 70, 43, 44, 73, ...:** Buscando 54.\n  - `44<54` (dir) → `73`. O nó 73 não pode estar na subárvore direita de 44 se esta subárvore também estiver contida na subárvore esquerda de 70 (pois `73 > 70`). **Esta sequência é INVÁLIDA.**\n\n**Conclusão:** Como as alternativas (a) e (c) são sequências de busca válidas, e a questão pede apenas uma resposta, há uma ambiguidade. No entanto, se formos seguir estritamente o gabarito oficial (letra e), a justificativa seria que todas as opções contêm alguma falha não aparente ou que a questão foi mal formulada, levando à sua anulação implícita ao se escolher 'nenhuma das anteriores'."
  }
]